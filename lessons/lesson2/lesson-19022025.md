- [REST Api](#rest-api)
  - [I sei principi di REST](#i-sei-principi-di-rest)
    - [Cos'è una risorsa?](#cosè-una-risorsa)
- [HTTP Methods](#http-methods)
  - [HTTP GET](#http-get)
    - [Codici di risposta](#codici-di-risposta)
  - [HTTP POST](#http-post)
  - [HTTP PUT](#http-put)
  - [HTTP DELETE](#http-delete)
    - [Codici di risposta](#codici-di-risposta-1)
  - [HTTP PATCH](#http-patch)
- [Status Codes](#status-codes)
  - [1xx: Informational](#1xx-informational)
  - [2xx: Success](#2xx-success)
  - [3xx Redirection](#3xx-redirection)
  - [4xx Client ErrorStatus Code Description](#4xx-client-errorstatus-code-description)
  - [5xx Server Error](#5xx-server-error)
  - [HTTP REST codici di stato](#http-rest-codici-di-stato)
- [REST API URI convenzioni di denominazione e best practices](#rest-api-uri-convenzioni-di-denominazione-e-best-practices)
  - [1.1. Singleton o collezione di risorse](#11-singleton-o-collezione-di-risorse)
  - [1.2 Collezioni e sub-collezioni di risorse](#12-collezioni-e-sub-collezioni-di-risorse)
  - [Best Practices](#best-practices)
  - [Usa nomi per rappresentare le risorse](#usa-nomi-per-rappresentare-le-risorse)
  - [La consistenza è la chiave fondamentale](#la-consistenza-è-la-chiave-fondamentale)
    - [Usare / per indicare relazioni gerarchiche](#usare--per-indicare-relazioni-gerarchiche)
    - [NON usare / a fine URI](#non-usare--a-fine-uri)
    - [Usa - per migliorare la leggibilità degli URI](#usa---per-migliorare-la-leggibilità-degli-uri)
    - [NON usare \_](#non-usare-_)
    - [Usa lettere minuscole](#usa-lettere-minuscole)
  - [Non usare l'estensione di file](#non-usare-lestensione-di-file)
  - [Non usare le funzioni CRUD nel URI](#non-usare-le-funzioni-crud-nel-uri)
  - [Usa l'URI per filtrare i dati](#usa-luri-per-filtrare-i-dati)
  - [NON usare verbi nella URI](#non-usare-verbi-nella-uri)
- [API REST idempotente](#api-rest-idempotente)
  - [Idempotenza con HTTP](#idempotenza-con-http)
  - [Gestione delle operazioni non idempotenti](#gestione-delle-operazioni-non-idempotenti)
- [Versioning REST APIs](#versioning-rest-apis)
  - [Quando implementare una nuova versione?](#quando-implementare-una-nuova-versione)
  - [Come versionare REST API](#come-versionare-rest-api)
- [Statelessness in REST API](#statelessness-in-rest-api)
  - [Cos'è una stateless REST API?](#cosè-una-stateless-rest-api)
  - [Stato dell'applicazione vs. Stato delle risorse](#stato-dellapplicazione-vs-stato-delle-risorse)
  - [Vantaggi di utilizzare API REST stateless](#vantaggi-di-utilizzare-api-rest-stateless)

# REST Api

REST è l'acronimo di **RE**presentational **S**tate **T**ransfer ed è un **insieme di principi architetturali** che definiscono come le risorse web dovrebbero essere definite e accessibili.
Durante il processo di sviluppo i programmatori possono adottare REST per creare le API.

> Un'API Web (o un servizio Web) che rispetta lo stile architetturale REST è chiamata API REST (o API RESTful).

## I sei principi di REST

1. **Uniform Interface**: definire un interfaccia uniforme e consistente per le interazioni tra client e server. (es. HTTP-Rest API usa GET, POST, PUT, DELETE ecc. e URI per l'identificazione delle risorse)

   - **Identificazione delle risorse**: Ogni risorsa deve essere identificata univocamente tramite un URI.
   - **Rappresentazione delle risorse**: Le risorse possono essere rappresentate in diversi formati (XML, JSON, HTML, ecc.).
   - **Manipolazione delle risorse tramite rappresentazioni**: Le rappresentazioni delle risorse devono contenere informazioni sufficienti per modificare o eliminare la risorsa stessa.
   - **Hypermedia come motore dello stato dell'applicazione (HATEOAS)**: Le rappresentazioni delle risorse devono contenere link ipertestuali per navigare tra le risorse.

2. **Client-Server**: Separare l'interfaccia utente dallo storage dei dati. Questo permette di migliorare la portabilità tra diverse piattaforme e di scalare il sistema in modo indipendente.

3. **Stateless**: Ogni richiesta da parte del client deve contenere tutte le informazioni necessarie per soddisfare la richiesta. Il server non deve mantenere alcuna informazione sullo stato del client.

4. **Cacheable**: Le risposte alle richieste devono essere esplicitamente contrassegnate come cacheable o non-cacheable. Questo permette ai client di memorizzare le risposte e di riutilizzarle per richieste future.

5. **Layered System**: Un client non deve essere in grado di distinguere se sta comunicando direttamente con il server finale o con un intermediario. Questo permette di scalare il sistema aggiungendo livelli intermedi.

6. **Code on Demand (optional)**: Il server può trasferire codice eseguibile al client per estendere le funzionalità del client stesso. Questo principio è opzionale e non è sempre necessario.

### Cos'è una risorsa?

Una risorsa è un concetto chiave in REST. Una risorsa è un oggetto o un **insieme di dati** che può essere **referenziato tramite un URI**.

Ad esempio, un'immagine, un file, un documento, un utente, ecc. possono essere considerati risorse. Le risorse possono essere **manipolate tramite rappresentazioni**.

Una rappresentazione è una forma di una risorsa in un formato specifico (es. **JSON**, **XML**, **HTML**, ecc.). Le rappresentazioni delle risorse possono essere trasferite tra client e server.

```json
{
  "id": 1,
  "name": "John Doe",
  "email": "..."
}
```

Lo stato di una risorsa è una terna di valori:

- I **dati** veri e propri
- I **metadati** che descrivono i dati (es. lunghezza, tipo, formato, ecc.)
- I **collegamenti ipertestuali** che permettono di navigare tra le risorse

# HTTP Methods

Le linee guida REST suggeriscono di usare specifiche chiamate HTTP ( GET, POST, DELETE, ecc. ) per eseguire operazioni su risorse. Queste chiamate sono chiamate **HTTP methods**.

## HTTP GET

Il metodo **GET** deve venire utilizzato solo per **RECUPERARE** informazioni dal server. Non deve avere effetti collaterali sul server.

Il metodo GET è **safe** e **idempotent**:

- **Safe**: Non modifica lo stato del server.
- **Idempotent**: Eseguire la stessa richiesta più volte produce lo stesso risultato (a patto che la base dati rimanga costante).

### Codici di risposta

- **200 OK**: La richiesta è stata completata con successo.
- **404 Not Found**: La risorsa richiesta non è stata trovata.
- **400 Bad Request**: La richiesta non è stata compresa dal server.

```http
HTTP GET http://www.appdomain.com/users
HTTP GET http://www.appdomain.com/users/123/address
```

## HTTP POST

Il metodo **POST** viene utilizzato per **CREARE** nuove risorse sul server. Se parlaimo di REST allora questo metodo deve creare una nuova risorsa dentro una collezione di risorse.

Il metodo POST nè **non è idempotente** nè **safe**.
Questo perchè invocare più volte la stessa richiesta può creare risorse duplicate.

```http
HTTP POST http://www.appdomain.com/users
```

## HTTP PUT

Il metodo **PUT** viene utilizzato per **AGGIORNARE INTERAMENTE** una risorsa esistente sul server. Se la risorsa non esiste, PUT può crearla.

Il metodo PUT è **idempotente** (produce lo stesso risultato chiamato più volte sulla stessa risorsa) ma **non safe** (modifica la base dati).

```http
HTTP PUT http://www.appdomain.com/users/123
```

> La differenza tra PUT e POST può essere osservata nella richiesta: PUT richiede l'URI della singola risorsa da aggiornare, mentre POST richiede l'URI della collezione di risorse in cui creare una nuova risorsa.

## HTTP DELETE

Il metodo **DELETE** viene utilizzato per **ELIMINARE** una risorsa esistente sul server, identificata dall'URI.

Il metodo DELETE è **idempotente** (produce lo stesso risultato chiamato più volte sulla stessa risorsa) ma **non safe** (modifica la base dati).

### Codici di risposta

- **200 OK**: La risorsa è stata eliminata con successo.
- **202 Accepted**: La richiesta è stata accettata per l'elaborazione, ma la risorsa non è stata eliminata.
- **204 No Content**: La risorsa è stata eliminata con successo, ma non c'è contenuto da restituire.
- **404 Not Found**: La risorsa richiesta non è stata trovata.

```http
HTTP DELETE http://www.appdomain.com/users/123
```

## HTTP PATCH

Il metodo **PATCH** viene utilizzato per **AGGIORNARE PARZIALMENTE** una risorsa esistente sul server. Il metodo PATCH è **idempotente** e **non safe**.

Non tutti i browser supportano PATCH.

```http
HTTP PATCH http://www.appdomain.com/users/123
[{ "op": "replace", "path": "/email", "value": "new.email@example.org" }]
```

Le operazioni possibili sono le seguenti, secondo le specifiche HTTP.

```json
[
  { "op": "test", "path": "/a/b/c", "value": "foo" },
  { "op": "remove", "path": "/a/b/c" },
  { "op": "add", "path": "/a/b/c", "value": ["foo", "bar"] },
  { "op": "replace", "path": "/a/b/c", "value": 42 },
  { "op": "move", "from": "/a/b/c", "path": "/a/b/d" },
  { "op": "copy", "from": "/a/b/d", "path": "/a/b/e" }
]
```

| HTTP   | Method                | CRUD Collection Resource (e.g. /users)                                                                  | Single Resouce (e.g. /users/123)                                                 |
| ------ | --------------------- | ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| POST   | Create                | 201 (Created), ‘Location’ header with link to /users/{id} containing new ID                             | Avoid using POST on a single resource                                            |
| GET    | Read                  | 200 (OK), list of users. Use pagination, sorting, and filtering to navigate big lists                   | 200 (OK), single user. 404 (Not Found), if ID not found or invalid               |
| PUT    | Update/Replace        | 405 (Method not allowed), unless you want to update every resource in the entire collection of resource | 200 (OK) or 204 (No Content). Use 404 (Not Found), if ID is not found or invalid |
| PATCH  | Partial Update/Modify | 405 (Method not allowed), unless you want to modify the collection itself                               | 200 (OK) or 204 (No Content). Use 404 (Not Found), if ID is not found or invalid |
| DELETE | Delete                | 405 (Method not allowed), unless you want to delete the whole collection — use with caution             | 200 (OK). 404 (Not Found), if ID not found or invalid                            |

# Status Codes

Le specifiche HTTP definiscono questi codici di stato standard, suddivisi in cinque categorie, che possono essere utilizzati per comunicare i risultati della richiesta di un client.

- **1xx**: Informazioni - Richiesta ricevuta, il server continua con il processo.
- **2xx**: Successo - La richiesta è stata ricevuta, compresa e accettata con successo.
- **3xx**: Redirezione - Ulteriori azioni devono essere intraprese per completare la richiesta.
- **4xx**: Errore del cliente - La richiesta contiene sintassi errata o non può essere completata.
- **5xx**: Errore del server - Il server non è in grado di completare la richiesta a causa di un errore interno.

Alcuni dei codici di stato più comuni sono:

## 1xx: Informational

| Status       | Code Description                                                                                                                                                                                                                                                                                                                                                     |
| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 100 Continue | An interim response. Indicates to the client that the initial part of the request has been received and has not yet been rejected by the server. The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response. The server MUST send a final response after the request has been completed. |

## 2xx: Success

| Status                | Code Description                                                                                                                                                                                                                                                    |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 200 OK                | Indicates that the request has succeeded.                                                                                                                                                                                                                           |
| 201 Created           | Indicates that the request has succeeded and a new resource has been created as a result.                                                                                                                                                                           |
| 202 Accepted          | Indicates that the request has been received but not completed yet. It is typically used in log running requests and batch processing.                                                                                                                              |
| 203 Non-Authoritative | Information Indicates that the returned metainformation in the entity header is not the definitive set as available from the origin server but is gathered from a local or third-party copy. The set presented MAY be a subset or superset of the original version. |
| 204 No Content        | The server has fulfilled the request but does not need to return a response body. The server may return the updated meta information.                                                                                                                               |
| 205 Reset Content     | Indicates the client to reset the document that sent this request.                                                                                                                                                                                                  |
| 206 Partial Content   | It is used when the Range header is sent from the client to request only part of a resource.                                                                                                                                                                        |

## 3xx Redirection

| Status Code           | Description                                                                                                                                                                                                          |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 300 Multiple Choices  | The request has more than one possible response. The user-agent or user should choose one of them.                                                                                                                   |
| 301 Moved Permanently | The URL of the requested resource has been changed permanently. The new URL is given by the Location header field in the response. This response is cacheable unless indicated otherwise.                            |
| 302 Found             | The URL of the requested resource has been changed temporarily. The new URL is given by the Location field in the response. This response is only cacheable if indicated by a Cache-Control or Expires header field. |
| 303 See Other         | The response can be found under a different URI and SHOULD be retrieved using a GET method on that resource.                                                                                                         |
| 304 Not Modified      | Indicates the client that the response has not been modified, so the client can continue to use the same cached version of the response.                                                                             |

## 4xx Client ErrorStatus Code Description

| Status Code            | Description                                                                                                                                       |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| 400 Bad Request        | The server could not understand the request due to incorrect syntax. The client should NOT repeat the request without modifications.              |
| 401 Unauthorized       | Indicates that the request requires user authentication information. The client MAY repeat the request with a suitable Authorization header field |
| 403 Forbidden          | Unauthorized request. The client does not have access rights to the content. Unlike 401, the client’s identity is known to the server.            |
| 404 Not Found          | The server can not find the requested resource.                                                                                                   |
| 405 Method Not Allowed | The server knows the request HTTP method, but it has been disabled and cannot be used for that resource.                                          |

## 5xx Server Error

| Status Code               | Description                                                                                                     |
| ------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 500 Internal Server Error | The server encountered an unexpected condition that prevented it from fulfilling the request.                   |
| 501 Not Implemented       | The HTTP method is not supported by the server and cannot be handled.                                           |
| 502 Bad Gateway           | The server got an invalid response while working as a gateway to get the response needed to handle the request. |
| 503 Service Unavailable   | The server is not ready to handle the request.                                                                  |
| 504 Gateway Timeout       | The server is acting as a gateway and cannot get a response in time for a request.                              |

## HTTP REST codici di stato

Codici di stato HTTP specifici per REST sono:

- **200 OK**: dovrebbe contenere il payload richiesto.
- **201 Created**: il server dovrebbe creare una risorsa prima di rispondere con questo codice, altrimenti dovrebbe restituire 202 Accepted.
- **204 No Content**: dovrebbe essere restituito quando non c'è contenuto da restituire.
- **301 Moved Permanently**: L'API REST deve specificare il nuovo URI nell'intestazione Location della risposta.
- **400 Bad Request**: dovrebbe essere restituito quando la richiesta non può essere elaborata a causa di errori di sintassi. Il client non dovrebbe ripetere la richiesta senza modifiche.
- **401 Unauthorized**: dovrebbe essere restituito quando l'utente non è autorizzato a eseguire l'operazione richiesta.
- **403 Forbidden**: dovrebbe essere restituito quando l'utente è autorizzato e autenticato, ma non ha i permessi necessari per eseguire l'operazione richiesta.
- **404 Not Found**: dovrebbe essere restituito quando la risorsa richiesta non è disponibile.

# REST API URI convenzioni di denominazione e best practices

## 1.1. Singleton o collezione di risorse

Le API REST dovrebbero utilizzare URI per identificare le [risorse](#cosè-una-risorsa). Le risorse possono essere identificate come **singleton** o **collezioni**.

- **Singleton**: Una risorsa singola è una risorsa che non ha sotto-risorse. Ad esempio, un'immagine, un file, un documento, un utente, ecc.
- **Collezione**: Una collezione di risorse è un insieme di risorse. Ad esempio, una lista di utenti, una lista di immagini, ecc.

```http
/customers			//is a collection resource
/customers/{id}		// is a singleton resource
```

## 1.2 Collezioni e sub-collezioni di risorse

Una risorsa può contenere altre risorse. Ad esempio, un utente può avere una lista di account, di indirizzi.

```http
/customers						//is a collection resource
/customers/{id}/accounts		// is a sub-collection resource
/customers/{id}/accounts/{accountId}	// is a singleton resource
```

REST API fanno largo uso delle URI (Uniform Resource Identifier) per identificare le risorse. Le URI dovrebbero essere **autoesplicative** e **facili da leggere**.

## Best Practices

## Usa nomi per rappresentare le risorse

Le **RESTful URI** dovrebbero far riferimento ad una cosa, nome, e non ad un'azione, verbo.

```http
/device-management/managed-devices
/device-management/managed-devices/{device-id}
/user-management/users
/user-management/users/{id}
```

Per una migliore chiarezza possiamo dividere le risorse in **singole risorse/Documenti**, **collezioni** **store**.

1. **Singole risorse/Documenti**: Le risorse che rappresentano un singolo oggetto dovrebbero essere identificate da un singolo nome al singolare.

```http
http://api.example.com/device-management/managed-devices/{device-id}
http://api.example.com/user-management/users/{id}
http://api.example.com/user-management/users/admin
```

2. **Collezioni**: Le risorse che rappresentano una collezione di oggetti dovrebbero essere identificate da un nome al plurale.

```http
/device-management/managed-devices
/user-management/users
/user-management/users/{id}/accounts
```

3. **Store**: Le risorse che rappresentano un negozio dovrebbero essere identificate da un nome al plurale.

```http
/song-management/users/{id}/playlists
```

## La consistenza è la chiave fondamentale

Utilizzare convenzioni di denominazione delle risorse e formattazione degli URI coerenti per ridurre al minimo le ambiguità e massimizzare la **leggibilità** e la **manutenibilità**.

È possibile implementare i seguenti suggerimenti di progettazione per ottenere coerenza:

### Usare / per indicare relazioni gerarchiche

```http
/device-management
/device-management/managed-devices
/device-management/managed-devices/{id}
/device-management/managed-devices/{id}/info
```

### NON usare / a fine URI

```http
http://api.example.com/device-management/managed-devices/
http://api.example.com/device-management/managed-devices        //MIGLIORE!
```

### Usa - per migliorare la leggibilità degli URI

```http
http://api.example.com/devicemanagement/manageddevices/
http://api.example.com/device-management/managed-devices 	//MIGLIORE!
```

### NON usare \_

```http
http://api.example.com/inventory-management/managed-entities/{id}/install-script-location  //Più leggibile

http://api.example.com/inventory-management/managedEntities/{id}/installScriptLocation  //Meno leggibile
```

### Usa lettere minuscole

```http
http://api.example.com/device-management/managed-devices
http://api.example.com/Device-Management/Managed-Devices  //NO!
```

## Non usare l'estensione di file

Le API RESTful dovrebbero evitare l'uso di estensioni di file nei URI, per comunicare il type della risorsa di deve preferire l'uso del `Content-Type` header.

```http
/device-management/managed-devices 	/*URI Corretta*/
/device-management/managed-devices.json 	/*URI Errata*/
```

## Non usare le funzioni CRUD nel URI

Non si dovrebbero usare gli URI per indicare una funzione CRUD.

Gli URI devono essere usati solo per identificare le risorse e non per eseguire azioni su di esse in modo univoco.

```http
HTTP GET /device-management/managed-devices
HTTP POST /device-management/managed-devices

HTTP GET /device-management/managed-devices/{id}
HTTP PUT /device-management/managed-devices/{id}
HTTP DELETE /device-management/managed-devices/{id}
```

## Usa l'URI per filtrare i dati

Spesso si incontrano requisiti che richiedono un insieme di risorse ordinate, filtrate o limitate in base a qualche attributo specifico della risorsa.

Per questi requisiti, non bisogna creare nuove API, ma abilitare le funzionalità di ordinamento, filtraggio e paginazione nelle API di raccolta delle risorse e passare i parametri di input come parametri di query.

```http
/device-management/managed-devices
/device-management/managed-devices?region=USA
/device-management/managed-devices?region=USA&brand=XYZ
/device-management/managed-devices?region=USA&brand=XYZ&sort=installation-date
```

## NON usare verbi nella URI

Non è corretto usare verbi nella URI, infatti le API RESTful dovrebbero usare nomi per rappresentare le risorse.

Se usiamo verbi nella URI, stiamo creano un'API RPC-like (Remote Procedure Call), non una vera API RESTful.

```http
/device-management/managed-devices/{id}/scripts/{id}/execute    //è RPC, e non REST
```

Se dobbiamo eseguire un'azione su una risorsa, dovremmo usare i metodi HTTP per eseguire l'azione.

```http
/device-management/managed-devices/{id}/scripts/{id}/execute	//NO!

/device-management/managed-devices/{id}/scripts/{id}/status		//POST request con action=execute
```

# API REST idempotente

Una API REST è **idempotente** se produce lo stesso risultato quando chiamata più volte con gli stessi parametri. Quindi il risultato rimane costante.

In aritmetica, aggiungere o togliere 0 da un numero non cambia il risultato. Questo è un esempio di idempotenza.

Dobbiamo considerare il fatto che il client può inviare più volte la stessa richiesta a causa di problemi di rete, timeout, ecc, dunque serve un approccio di **Tolleranza**.

Inoltre possono essere utilzzate per effettuare **caching** delle risposte.

## Idempotenza con HTTP

Se seguiamo i principi REST nella progettazione delle nostre API, avremo API REST automaticamente idempotenti per i metodi:

- GET,
- PUT,
- DELETE,
- HEAD,
- OPTIONS
- TRACE.

Solo le API `POST` e `PATCH` **non saranno idempotenti**.

<style>
r { background:rgb(235, 84, 67); padding: 0 5px; border-radius: 5px; color: black }
g { background:rgb(150, 231, 116); padding: 0 5px; border-radius: 5px; color: black }
</style>

<div align="center">

| HTTP methods | Idempotent | Safe       |
| ------------ | ---------- | ---------- |
| GET          | <g>Yes</g> | <g>Yes</g> |
| HEAD         | <g>Yes</g> | <g>Yes</g> |
| PUT          | <g>Yes</g> | <r>No</r>  |
| DELETE       | <g>Yes</g> | <r>No</r>  |
| POST         | <r>No</r>  | <r>No</r>  |
| PATCH        | <r>No</r>  | <r>No</r>  |

</div>

Generalmente, ma non sempre, `POST`, chiamata N volte produce N oggetti lato server, e `PATCH` non sono idempotenti. Ma è possibile rendere queste API idempotenti, se progettate correttamente.

I metodi `GET` e `HEAD` metodi invece non hanno alcun effetto lato server, non hanno accesso in scrittura.

Il metodo `PUT` è idempotente, poiché aggiornare un oggetto con lo stesso contenuto non cambia il risultato, lo sovrascrie.

Il metodo `DELETE` è idempotente, poiché eliminare un oggetto due volte non cambia il risultato, cambia il valore di ritorno (200 OK, 404 Not Found).

> Da notare che questo metodo può non essere più idempotente nel caso di eliminazione per esempio dell'ultimo elemento inserito (DELETE /item/last). Soluzione: Usare POST.

## Gestione delle operazioni non idempotenti

Un operazione che deve essere gestita in modo non idempotente è la **creazione di un nuovo account**, o altri tipi di risorse che devono essere **uniche**.

Per fare ciò possiamo utilizzare **token** che identifica la richiesta, e che può essere utilizzato per evitare duplicati e/o meccanismi di transazione.

# Versioning REST APIs

Le API RESTful dovrebbero essere progettate per essere **versionate**. La versione delle API è importante per garantire che le modifiche apportate alle API non interrompano le applicazioni client esistenti.

## Quando implementare una nuova versione?

- **Quando si cambia il formato della risposta**: Nuovi campi, campi obbligatori, campi opzionali, ecc.
- **Quando si cambia il formato della richiesta**: da intero --> float
- **Quando si rimuove una qualsiasi parte della API**

> Grandi cambiamenti dovrebbero essere gestiti con una nuova versione, mentre piccoli cambiamenti possono essere gestiti con la stessa versione (es. aggiunta di nuovi endpoint).

## Come versionare REST API

Ci sono diversi modi per versionare le API REST:

1. **URI versioning**: Includere la versione nella URI. Il più semplice e il più utilizzato.

   ```http

   http://api.example.com/v1/users
   https://api.stripe.com/v1/charges
   https://graph.facebook.com/v10.0/me
   https://api.github.com/v3/repos/{owner}/{repo}

   ```

2. **Custom Request Header**: Includere la versione come header personalizzato. Questo permette di mantenere l'URI pulita. (Non è un approccio standard)

   ```http
   X-API-Version: 2
   ```

3. **Usare "Accept" header**: Includere la versione come parte dell'intestazione Accept.

   ```http
   Accept: application/vnd.myapi.v1+json
   ```

# Statelessness in REST API

Lo **Stateless** è uno dei principi fondamentali di REST. Significa che ogni richiesta HTTP deve contenere tutte le informazioni necessarie per soddisfare la richiesta e dunque il server non deve mantenere **NESSUNA** informazione dei client e deve trattare ogni richiesta come se fosse la prima (nuova).

<div align="center">     
<img src="../../img/Stateless-REST-API.webp" alt="MVC" width="500px" height="auto" align="centre" />
</div>

## Cos'è una stateless REST API?

Significa aderire ai principi di stateless: **il client deve inviare tutte le informazioni necessarie per soddisfare la richiesta**.

Inoltre il client è RESPONSABILE per la memorizzazione e gestione delle informazioni relative alla sessione.

Per consentire ai client di accedere a queste API stateless, è necessario che i server includano anche tutte le informazioni di cui il client potrebbe aver bisogno per creare/mantenere lo stato sul proprio lato.

## Stato dell'applicazione vs. Stato delle risorse

- **Stato dell'applicazione**: Si riferisce allo stato dell'applicazione lato server. Ad esempio, le sessioni utente, i cookie, ecc.

- **Stato delle risorse**: Si riferisce allo stato delle risorse lato server. Ad esempio, i dati delle risorse, i metadati, ecc.

## Vantaggi di utilizzare API REST stateless

- **Scalabilità**: Poiché non c'è stato da mantenere, i server possono gestire più richieste simultaneamente e servire migliaia di clienti.
- **Affidabilità**: Poiché non c'è stato da mantenere, non c'è bisogno di gestire problemi di sincronizzazione dello stato.
- **Semplicità**: Poiché non c'è stato da mantenere, le API REST stateless sono più semplici da progettare, implementare e testare.
- **Easy to cache**: Poiché le API REST stateless non mantengono lo stato, le risposte possono essere facilmente memorizzate nella cache.
- **Tracciabilità**: Il server non perde mai la traccia di "dove" si trova ogni client nell'applicazione, perché il client invia tutte le informazioni necessarie a ogni richiesta.
