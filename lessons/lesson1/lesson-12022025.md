# Programmazione ad oggetti

- [Programmazione ad oggetti](#programmazione-ad-oggetti)
  - [Introduzione](#introduzione)
  - [Classi e oggetti](#classi-e-oggetti)
  - [Principi fondamentali](#principi-fondamentali)
    - [Vantaggi della programmazione ad oggetti](#vantaggi-della-programmazione-ad-oggetti)
  - [Interfaccia Vs Classe Astratta](#interfaccia-vs-classe-astratta)
    - [Diamond Problem](#diamond-problem)

## Introduzione

La programmazione orientata ad oggetti (OOP - Object Oriented Programming) è un paradigma di programmazione che permette di modellare il mondo reale in modo più semplice e intuitivo.

In questo paradigma, i dati e le operazioni che possono essere eseguite su di essi sono raggruppati in un'unica entità chiamata **oggetto**.

## Classi e oggetti

Una classe è un modello che definisce le caratteristiche (**attributi**) e il comportamento (**metodi**) di un oggetto. Un oggetto è un'istanza di una classe.

```typescript
class Persona {
  private nome: string;
  private cognome: string;
  private eta: number;

  constructor(nome: string, cognome: string, eta: number) {
    this.nome = nome;
    this.cognome = cognome;
    this.eta = eta;
  }

  saluta() {
    console.log(`Ciao, mi chiamo ${this.nome} ${this.cognome}`);
  }
}
```

## Principi fondamentali

- **Ereditarietà**: permette di creare nuove classi basate su classi esistenti. La classe figlia eredita gli attributi e i metodi della classe padre, ciò favorisce il riutilizzo del codice.

```typescript
class Studente extends Persona {
  private matricola: string;

  constructor(nome: string, cognome: string, eta: number, matricola: string) {
    super(nome, cognome, eta);
    this.matricola = matricola;
  }

  studia() {
    console.log(`Lo studente ${this.nome} ${this.cognome} sta studiando`);
  }
}
```

- **Polimorfismo**: permette a oggetti di classi diverse di rispondere allo stesso messaggio in modi diversi.

```typescript
class Animale {
  muovi() {
    console.log("L'animale si muove");
  }
}

class Cane extends Animale {
  muovi() {
    console.log("Il cane cammina");
  }
}

class Pesce extends Animale {
  muovi() {
    console.log("Il pesce nuota");
  }
}
```

- **Incapsulamento**: nascondere i dettagli di implementazione di un oggetto e permettere l'accesso solo ai metodi pubblici.

```typescript
class ContoCorrente {
  private saldo: number;

  constructor(saldo: number) {
    this.saldo = saldo;
  }

  preleva(importo: number) {
    if (importo > this.saldo) {
      console.log("Saldo insufficiente");
      return;
    }

    this.saldo -= importo;
    console.log(`Hai prelevato ${importo} euro`);
  }

  deposita(importo: number) {
    this.saldo += importo;
    console.log(`Hai depositato ${importo} euro`);
  }

  getSaldo() {
    return this.saldo;
  }
}
```

- **Astrazione**: permette di definire un'interfaccia, firma, per un oggetto, nascondendo i dettagli di implementazione.

```typescript
abstract class Veicolo {
  protected marca: string;
  protected modello: string;

  constructor(marca: string, modello: string) {
    this.marca = marca;
    this.modello = modello;
  }

  public getInfo(): string {
    return `${this.marca} ${this.modello}`;
  }

  abstract avvia(): void;
}

class Auto extends Veicolo {
  private numeroPorte: number;

  constructor(marca: string, modello: string, numeroPorte: number) {
    super(marca, modello);
    this.numeroPorte = numeroPorte;
  }

  avvia(): void {
    console.log(`L'auto ${this.getInfo()} si è avviata con il motore`);
  }
}

// const veicolo = new Veicolo("Generic", "Vehicle"); // Errore!

const auto = new Auto("Fiat", "Panda", 5);
auto.avvia();
```

### Vantaggi della programmazione ad oggetti

- Codice più organizzato e modulare
- Maggiore riutilizzabilità
- Più facile da mantenere e modificare
- Migliore gestione della complessità

## Interfaccia Vs Classe Astratta

Le differenze chiave sono:

1. Implementazione dei metodi:
   1. Interfaccia: può contenere SOLO dichiarazioni, firma, di metodi (no implementazioni)
   2. Classe Astratta: può avere sia metodi astratti CHE metodi implementati
2. Accessibilità:
   1. Interfaccia: una classe può implementare MULTIPLE interfacce
   2. Classe Astratta: una classe può estendere UNA SOLA classe astratta. Questo per evitare il problema del diamante (diamond problem)
3. Ereditarietà
   1. Interfaccia: creando un interfaccia la classe può decidere se implementarlo o meno
   2. Classe Astratta: la classe DEVE implementare i metodi astratti della classe astratta (se ho 500 classi che estendono la classe astratta, devo implementare i metodi astratti in tutte le 500 classi)

### Diamond Problem

Il problema del diamante si verifica quando una classe eredita da due classi che a loro volta ereditano dalla stessa classe. Questo può causare ambiguità e problemi di implementazione.

Con `virtual` possiamo ottenere:

<div align="center">
     A<br>
    / &nbsp &nbsp &nbsp  \<br>
    B &nbsp &nbsp &nbsp  C<br>
    \ &nbsp &nbsp &nbsp  /<br>
     D
</div>

Senza `virtual`:

<div align="center">
    A &nbsp &nbsp &nbsp &nbsp  A<br>
    | &nbsp &nbsp &nbsp &nbsp  &nbsp |<br>
    B &nbsp &nbsp &nbsp &nbsp  C<br>
    \ &nbsp  &nbsp &nbsp &nbsp /<br>
     D

</div>

Alcuni linguaggi di programmazione, come `Java`, `typescript`, `C#`, risolvono il problema del diamante permettendo l'ereditarietà multipla solo per le interfacce.
**Una classe può implementare multiple interfacce ma estendere solo una classe astratta.**

In altri linguaggi, come `C++`, è possibile ereditare da più classi, ma bisogna fare attenzione a come si utilizzano le classi base.

Per questo motivo `C++` mette a disposizione la parola chiave `virtual` per risolvere il problema del diamante.

```cpp
class A {
public:
    A() { std::cout << "A::A()" << std::endl; }
};

class B : public A {
public:
    B(): A() { std::cout << "B::B()" << std::endl; }
};

class C : public A {
public:
    C(): A() { std::cout << "C::C()" << std::endl; }
};

class D : public B, public C {
public:
    D(): B(), C() { std::cout << "D::D()" << std::endl; }
};
```

output:

```plaintext
A::A()
B::B()
A::A()
C::C()
D::D()
```

La parola chiave `virtual` fa sì che: Venga creata una SOLA istanza della classe base (A) e che le classi derivate (B e C) condividano la stessa istanza della classe base.

```cpp

class A {
public:
    A() { std::cout << "A::A()" << std::endl; }
};

class B : virtual public A {
public:
    B(): A() { std::cout << "B::B()" << std::endl; }
};

class C : virtual public A {
public:
    C(): A() { std::cout << "C::C()" << std::endl; }
};

class D : public B, public C {
public:
    D() : B(), C(), A() { std::cout << "D::D()" << std::endl; }
};

```

output:

```plaintext
A::A()    // Costruttore di A chiamato una volta sola grazie a virtual
B::B()
C::C()
D::D()    // Costruttore di D
```

`class B : virtual public A ` Significa che ogni classe che eredita da B, è responsabile della creazione di A, in quanto B non lo fa in maniera automatica.

In generale, non è consentito chiamare direttamente il costruttore del parent, deve
essere chiamato tramite la classe genitore.

È consentito solo quando viene utilizzata la parola chiave "virtual".
