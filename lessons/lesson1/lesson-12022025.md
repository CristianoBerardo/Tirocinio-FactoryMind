# Programmazione ad oggetti

- [Programmazione ad oggetti](#programmazione-ad-oggetti)
  - [Introduzione](#introduzione)
  - [Classi e oggetti](#classi-e-oggetti)
  - [Principi fondamentali](#principi-fondamentali)
    - [Vantaggi della programmazione ad oggetti](#vantaggi-della-programmazione-ad-oggetti)
  - [Interfaccia Vs Classe Astratta](#interfaccia-vs-classe-astratta)
    - [Diamond Problem](#diamond-problem)
- [Passaggo di parametri](#passaggo-di-parametri)
- [Memoria](#memoria)
  - [Ricorsione vs Iterazione](#ricorsione-vs-iterazione)
- [Funzioni](#funzioni)
  - [Funzione pura](#funzione-pura)
  - [Funzioni idempotenti](#funzioni-idempotenti)
  - [Funzioni di ordine superiore (Higher-Order Functions)](#funzioni-di-ordine-superiore-higher-order-functions)

## Introduzione

La programmazione orientata ad oggetti (OOP - Object Oriented Programming) è un paradigma di programmazione che permette di modellare il mondo reale in modo più semplice e intuitivo.

In questo paradigma, i dati e le operazioni che possono essere eseguite su di essi sono raggruppati in un'unica entità chiamata **oggetto**.

## Classi e oggetti

Una classe è un modello che definisce le caratteristiche (**attributi**) e il comportamento (**metodi**) di un oggetto. Un oggetto è un'istanza di una classe.

```typescript
class Persona {
  private nome: string;
  private cognome: string;
  private eta: number;

  constructor(nome: string, cognome: string, eta: number) {
    this.nome = nome;
    this.cognome = cognome;
    this.eta = eta;
  }

  saluta() {
    console.log(`Ciao, mi chiamo ${this.nome} ${this.cognome}`);
  }
}
```

## Principi fondamentali

- **Ereditarietà**: permette di creare nuove classi basate su classi esistenti. La classe figlia eredita gli attributi e i metodi della classe padre, ciò favorisce il riutilizzo del codice.

```typescript
class Studente extends Persona {
  private matricola: string;

  constructor(nome: string, cognome: string, eta: number, matricola: string) {
    super(nome, cognome, eta);
    this.matricola = matricola;
  }

  studia() {
    console.log(`Lo studente ${this.nome} ${this.cognome} sta studiando`);
  }
}
```

- **Polimorfismo**: permette a oggetti di classi diverse di rispondere allo stesso messaggio in modi diversi.

```typescript
class Animale {
  muovi() {
    console.log("L'animale si muove");
  }
}

class Cane extends Animale {
  muovi() {
    console.log("Il cane cammina");
  }
}

class Pesce extends Animale {
  muovi() {
    console.log("Il pesce nuota");
  }
}
```

- **Incapsulamento**: nascondere i dettagli di implementazione di un oggetto e permettere l'accesso solo ai metodi pubblici.

```typescript
class ContoCorrente {
  private saldo: number;

  constructor(saldo: number) {
    this.saldo = saldo;
  }

  preleva(importo: number) {
    if (importo > this.saldo) {
      console.log("Saldo insufficiente");
      return;
    }

    this.saldo -= importo;
    console.log(`Hai prelevato ${importo} euro`);
  }

  deposita(importo: number) {
    this.saldo += importo;
    console.log(`Hai depositato ${importo} euro`);
  }

  getSaldo() {
    return this.saldo;
  }
}
```

- **Astrazione**: permette di definire un'interfaccia, firma, per un oggetto, nascondendo i dettagli di implementazione.

```typescript
abstract class Veicolo {
  protected marca: string;
  protected modello: string;

  constructor(marca: string, modello: string) {
    this.marca = marca;
    this.modello = modello;
  }

  public getInfo(): string {
    return `${this.marca} ${this.modello}`;
  }

  abstract avvia(): void;
}

class Auto extends Veicolo {
  private numeroPorte: number;

  constructor(marca: string, modello: string, numeroPorte: number) {
    super(marca, modello);
    this.numeroPorte = numeroPorte;
  }

  avvia(): void {
    console.log(`L'auto ${this.getInfo()} si è avviata con il motore`);
  }
}

// const veicolo = new Veicolo("Generic", "Vehicle"); // Errore!

const auto = new Auto("Fiat", "Panda", 5);
auto.avvia();
```

### Vantaggi della programmazione ad oggetti

- Codice più organizzato e modulare
- Maggiore riutilizzabilità
- Più facile da mantenere e modificare
- Migliore gestione della complessità

## Interfaccia Vs Classe Astratta

Le differenze chiave sono:

1. Implementazione dei metodi:
   1. Interfaccia: può contenere SOLO dichiarazioni, firma, di metodi (no implementazioni)
   2. Classe Astratta: può avere sia metodi astratti CHE metodi implementati
2. Accessibilità:
   1. Interfaccia: una classe può implementare MULTIPLE interfacce
   2. Classe Astratta: una classe può estendere UNA SOLA classe astratta. Questo per evitare il problema del diamante (diamond problem)
3. Ereditarietà
   1. Interfaccia: creando un interfaccia la classe può decidere se implementarlo o meno
   2. Classe Astratta: la classe DEVE implementare i metodi astratti della classe astratta (se ho 500 classi che estendono la classe astratta, devo implementare i metodi astratti in tutte le 500 classi)

### Diamond Problem

Il problema del diamante si verifica quando una classe eredita da due classi che a loro volta ereditano dalla stessa classe. Questo può causare ambiguità e problemi di implementazione.

Con `virtual` possiamo ottenere:

<div align="center">
     A<br>
    / &nbsp &nbsp &nbsp  \<br>
    B &nbsp &nbsp &nbsp  C<br>
    \ &nbsp &nbsp &nbsp  /<br>
     D
</div>

Senza `virtual`:

<div align="center">
    A &nbsp &nbsp &nbsp &nbsp  A<br>
    | &nbsp &nbsp &nbsp &nbsp  &nbsp |<br>
    B &nbsp &nbsp &nbsp &nbsp  C<br>
    \ &nbsp  &nbsp &nbsp &nbsp /<br>
     D

</div>

Alcuni linguaggi di programmazione, come `Java`, `typescript`, `C#`, risolvono il problema del diamante permettendo l'ereditarietà multipla solo per le interfacce.
**Una classe può implementare multiple interfacce ma estendere solo una classe astratta.**

In altri linguaggi, come `C++`, è possibile ereditare da più classi, ma bisogna fare attenzione a come si utilizzano le classi base.

Per questo motivo `C++` mette a disposizione la parola chiave `virtual` per risolvere il problema del diamante.

```cpp
class A {
public:
    A() { std::cout << "A::A()" << std::endl; }
};

class B : public A {
public:
    B(): A() { std::cout << "B::B()" << std::endl; }
};

class C : public A {
public:
    C(): A() { std::cout << "C::C()" << std::endl; }
};

class D : public B, public C {
public:
    D(): B(), C() { std::cout << "D::D()" << std::endl; }
};
```

output:

```plaintext
A::A()
B::B()
A::A()
C::C()
D::D()
```

La parola chiave `virtual` fa sì che: Venga creata una SOLA istanza della classe base (A) e che le classi derivate (B e C) condividano la stessa istanza della classe base.

```cpp

class A {
public:
    A() { std::cout << "A::A()" << std::endl; }
};

class B : virtual public A {
public:
    B(): A() { std::cout << "B::B()" << std::endl; }
};

class C : virtual public A {
public:
    C(): A() { std::cout << "C::C()" << std::endl; }
};

class D : public B, public C {
public:
    D() : B(), C(), A() { std::cout << "D::D()" << std::endl; }
};

```

output:

```plaintext
A::A()    // Costruttore di A chiamato una volta sola grazie a virtual
B::B()
C::C()
D::D()    // Costruttore di D
```

`class B : virtual public A ` Significa che ogni classe che eredita da B, è responsabile della creazione di A, in quanto B non lo fa in maniera automatica.

In generale, non è consentito chiamare direttamente il costruttore del parent, deve
essere chiamato tramite la classe genitore.

È consentito solo quando viene utilizzata la parola chiave "virtual".

# Passaggo di parametri

I parametri possono essere passati ai metodi in diversi modi:

- **By value**: il valore dell'argomento viene copiato nel parametro del metodo. Qualsiasi modifica al parametro all'interno del metodo non influisce sull'argomento originale.

```typescript
function incrementa(x: number) {
  x++;
}

let a = 10;
incrementa(a);
console.log(a); // 10
```

```cpp
void incrementa(int x) {
  x++;
}

int a = 10;
incrementa(a);

std::cout << a << std::endl; // 10
```

- **By reference**: il parametro del metodo contiene un riferimento all'argomento originale. Qualsiasi modifica al parametro all'interno del metodo influisce sull'argomento originale.

```typescript
function incrementa(x: { value: number }) {
  x.value++;
}

let a = { value: 10 };
incrementa(a);
console.log(a.value); // 11
```

```cpp
void incrementa(int& x) {
  x++;
}

int a = 10;
incrementa(a);
std::cout << a << std::endl; // 11
```

# Memoria

La divisione fondamentale della memoria di un qualsiasi computer è:

- `Stack`: contiene le variabili locali e i riferimenti ai metodi. È di dimensione fissa e viene liberata automaticamente quando la funzione termina.
- `Heap` contiene oggetti e variabili allocate dinamicamente. È di dimensione variabile e deve essere liberata manualmente o attraverso un garbage collector (vedi Java, C#).

## Ricorsione vs Iterazione

Con la **ricorsione** per ogni chiamata ricorsiva viene aggiunto un nuovo frame allo stack (parametri della funzione, indirizzo di ritorno, variabili locali).
Se la ricorsione è troppo profonda c'è un rischio di che si presenti l'errore di `stack overflow`, oltre al consumo eccessivo di memoria.

Con l'**iterazione** un singolo frame è sufficiente per eseguire l'intera funzione, inoltre le variabili locali e i parametri vengono riutilizzate.

# Funzioni

Una **procedura**, o **subroutine**, è una particolare tipo di funzione che non restituisce alcun valore.

Una **funzione** è un blocco di codice che esegue una specifica operazione. Prende in input dei **parametri** e restituisce un **valore di ritorno**.

```typescript
function somma(a: number, b: number): number {
  return a + b;
}
```

## Funzione pura

Le **funzioni pure** sono un sottoinsieme delle funzioni che aderiscono a due regole:

1. **Determinismo**: dati gli stessi input, una funzione pura produce sempre lo stesso output.
2. **Side-effect free**: una funzione pura non modifica lo stato del programma. Non interagisce con variabili globali, file, database o altri elementi esterni.

Ciò permette una maggiore facilità di test e di debug perché il loro comportamento dipende solo dagli input.

```typescript
function moltiplicaPerDue(x: number): number {
  return x * 2;
}
```

## Funzioni idempotenti

Le **funzioni idempotenti** sono funzioni che, **date le stesse condizioni iniziali**, restituiscono sempre lo stesso risultato.
Inoltre, l'applicazione ripetuta della funzione non modifica lo stato del sistema.

Es. una chiamata ad un database non è una funzione idempotente, perché il valore restituito può cambiare nel tempo.

## Funzioni di ordine superiore (Higher-Order Functions)

Si definisce **Higher-Order Functions** una funzione che accetta una o più funzioni come argomenti e/o restituisce una funzione.

```typescript
function customMap(a: number[], f: (x: number) => number): number[] {
  const result = [];

  for (let i = 0; i < a.length; i++) {
    result.push(f(a[i]));
  }

  return result;
}

const numeri = [1, 2, 3, 4, 5];
const quadrati = customMap(numeri, (x) => x * x);
```



