- [Django](#django)
  - [Caratteristiche](#caratteristiche)
- [Comandi frequenti](#comandi-frequenti)
- [Creare un nuovo progetto con Django REST Framework](#creare-un-nuovo-progetto-con-django-rest-framework)
- [Model](#model)
  - [Concetti chiave](#concetti-chiave)
- [View](#view)
  - [Tipologie di View in DRF:](#tipologie-di-view-in-drf)
- [Serializzatori](#serializzatori)
  - [Operazioni chiavi](#operazioni-chiavi)
- [Interconnessione dei componenti](#interconnessione-dei-componenti)
  - [Esempio di flusso di lavoro:](#esempio-di-flusso-di-lavoro)

# Django

Django è un framework web di alto livello che favorisce uno sviluppo rapido e un design pulito e pragmatico.

Costruito da sviluppatori esperti, si occupa di gran parte delle seccature dello sviluppo web, in modo tale che ci si possa concentrare sulla scrittura dell'applicazione senza dover "reinventare la ruota".

È **gratuito** e **open source**.

## Caratteristiche

- **Rapido sviluppo**: Django ti permette di scrivere applicazioni web in modo rapido e pulito.
- **Sicurezza rassicurante**: Django aiuta a proteggere le tue applicazioni web da attacchi comuni.
- **Estensibile**: Django è flessibile e scalabile, permettendoti di estendere le sue funzionalità.

# Comandi frequenti

```bash
.\venv\Scripts\activate
python manage.py runserver # avvia il server, usa lo script sopra per avviare l'ambiente virtuale

python manage.py makemigrations <app_name> # si comunica a Django che sono state apportate alcune modifiche ai modelli
python manage.py migrate # applica le migrazioni
```

# Creare un nuovo progetto con Django REST Framework

1. Creare una nuova directory per il progetto e spostarsi al suo interno:
   ```bash
   mkdir <nome_progetto>
   cd <nome_progetto>
   ```
2. Creare un ambiente virtuale:
   ```bash
   python3 -m venv <nome_ambiente_virtuale> # normalmente chiamato "venv"
   ```
3. Attivare l'ambiente virtuale (Windows):
   ```bash
   <nome_ambiente_virtuale>\Scripts\activate
   ```
4. Installare djangorestframework e altri pacchetti:
   ```bash
   pip install django djangorestframework django-filter
   ```
5. Creare un nuovo progetto:
   ```bash
   django-admin startproject <nome_progetto> .
   ```
6. Creare un'applicazione:
   ```bash
   django-admin startapp <nome_app>
   ```
7. Sincronizzare il database:
   ```bash
   python manage.py migrate
   ```
8. Creare un superutente e creare una password:
   ```bash
   python manage.py createsuperuser --username admin --email admin@example.com
   ```
9. Aggiungere l'applicazione al progetto:
   ```python
   INSTALLED_APPS = [
       ...
       '<nome_app>',
   ]
   ```
10. Creare un modello (<nome_app>/models.py):

    ```python
    from django.db import models

    class Example(models.Model):
        title = models.CharField(max_length=120)
        # ...
    ```

11. Creare un file di migrazione:
    ```bash
    python manage.py makemigrations <nome_app> # si comunica a Django che sono state apportate alcune modifiche ai modelli
    ```
12. Applicare le migrazioni:
    ```bash
    python manage.py migrate
    ```
13. Creare un serializzatore (<nome_app>/serializers.py):
    ```python
    from rest_framework import serializers
    from .models import Example
    ```
14. Creare una vista (<nome_app>/views.py):
    ```python
    from rest_framework import viewsets
    from .models import Example
    from .serializers import ExampleSerializer
    # ...
    ```
15. Creare un URL pattern (<nome_app>/urls.py):
    ```python
    from django.urls import path
    from .views import ExampleViewSet
    # ...
    ```
16. Aggiungere il URL pattern al file principale (<nome_progetto>/urls.py):

    ```python
    from django.urls import path
    from . import views

    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/', include('<nome_app>.urls')),
    ]
    ```

17. Avviare il server (prima bisogna avviare l'ambiente virtuale, [Punto 3](#creare-un-nuovo-progetto-con-django-rest-framework)):
    ```bash
    python manage.py runserver
    ```

# Model

Un **modello** è la classe Python che definisce la struttura della tabella del database, fungendo da livello di astrazione tra il database e il codice. Nel contesto di un'API, i modelli servono come rappresentazione fondamentale delle entità dei dati.

Questo include le migrazioni: a differenza di Ruby On Rails, per esempio, le migrazioni sono interamente derivate dal file dei modelli e sono essenzialmente una cronologia che Django può scorrere per aggiornare lo schema del database in modo che corrisponda ai modelli correnti.

## Concetti chiave

- Definisce lo schema del database
- Eredita da `django.db.models.Model`
- Specifica campi, relazioni e metadati
- Rappresenta una tabella del database
- Fornisce un'interfaccia ORM (Object-Relational Mapping)

```python
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)
    published_date = models.DateField()
    isbn = models.CharField(max_length=13, unique=True)

    def __str__(self):
        return self.title
```

# View

In Django REST Framework, una vista **gestisce la logica** di elaborazione delle richieste API e la restituzione delle risposte appropriate.
Le viste determinano come i dati vengono **recuperati**, **creati**, **aggiornati** o **cancellati** e interagiscono con i serializzatori per trasformare i dati tra oggetti Python complessi e JSON/altri tipi di contenuto.

## Tipologie di View in DRF:

1. `Function-Based Views`: Viste semplici con il decoratore _@api_view_
1. `Class-Based Views`: Più **potente** e **flessibile**
1. `Generic Views`: Fornire operazioni **CRUD** comuni
1. `ViewSets`: Combinare le operazioni di **creazione**, **recupero**, **aggiornamento** e **cancellazione** in un'unica classe

Esempio di class-based view:

```python
from rest_framework import viewsets
from .models import Book
from .serializers import BookSerializer

class BookViewSet(viewsets.ModelViewSet):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
```

# Serializzatori

I serializzatori in DRF fungono da **traduttori** tra tipi di dati complessi (come le istanze di modello di Django) e tipi primitivi di Python che possono essere facilmente resi in JSON, XML o altri tipi di contenuto.

Gestiscono sia la serializzazione (da Python a JSON) che la deserializzazione (da JSON a Python).

## Operazioni chiavi

- Validate incoming data
- Transform complex data types
- Control which fields are included/excluded
- Provide custom data transformation logic
- Support nested representations

```python
from rest_framework import serializers
from .models import Book

class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ['id', 'title', 'author', 'published_date', 'isbn']

    def validate_isbn(self, value):
        # Custom validation logic
        if not value.isdigit():
            raise serializers.ValidationError("ISBN must contain only digits")
        return value
```

# Interconnessione dei componenti

Questi tre componenti lavorano insieme senza soluzione di continuità:

- **Il modello** definisce la struttura dei dati
- **Il serializzatore** trasforma i dati del modello per il consumo dell'API (json --> python e viceversa)
- **La view** gestisce la logica di recupero e manipolazione dei dati.

## Esempio di flusso di lavoro:

1. Una richiesta GET colpisce il BookViewSet
1. La vista utilizza BookSerializer per convertire le istanze del modello Libro in JSON
1. Il serializzatore convalida e trasforma i dati
1. La risposta viene rinviata al client
